
/* 10. 有依赖的背包问题
   题目
   提交记录
   讨论
   题解
   视频讲解

有 N 个物品和一个容量是 V 的背包。

物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。

如下图所示：
QQ图片20181018170337.png

如果选择物品5，则必须选择物品1和2。这是因为2是5的父节点，1是2的父节点。

每件物品的编号是 i，体积是 vi，价值是 wi，依赖的父节点编号是 pi。物品的下标范围是 1…N。

求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。

输出最大价值。

输入格式
第一行有两个整数 N，V，用空格隔开，分别表示物品个数和背包容量。

接下来有 N 行数据，每行数据表示一个物品。
第 i 行有三个整数 vi,wi,pi，用空格隔开，分别表示物品的体积、价值和依赖的物品编号。
如果 pi=−1，表示根节点。 数据保证所有物品构成一棵树。

输出格式
输出一个整数，表示最大价值。

数据范围
1≤N,V≤100
1≤vi,wi≤100
父节点编号范围：

内部结点：1≤pi≤N;
根节点 pi=−1;
输入样例
5 7
2 3 -1
2 2 1
3 5 1
4 7 2
3 6 2
输出样例：
11 */








#include<iostream>
#include<vector>
using namespace std;
int f[110][110];//f[x][v]表达选择以x为子树的物品，在容量不超过v时所获得的最大价值
vector<int> g[110]; // g[i]表示i的son组成的数组.
int v[110],w[110];
int n,m,root;

int dfs(int x)
{
    for(int i=v[x];i<=m;i++) f[x][i]=w[x];//点x必须选，所以重量大于等于v[x]的时候都是w[x],小鱼v[x]时候我们都不管,也就是0.
    for(int i=0;i<g[x].size();i++)//遍历所有的子节点,子节点就是一个分组背包问题.
    {
        int y=g[x][i];//y是当前遍历到的子节点.
        dfs(y);//计算完子节点的值.
        //下面我们有了所有子节点,进行动态规划比较即可.
        for(int j=m;j>=v[x];j--)//01背包所以是整体体积的逆向遍历, 如果是完全背包就是整体体积的正向遍历. 从m到v[x]
        {
            for(int k=0;k<=j-v[x];k++)// 遍历y节点在各种体积k下的情况,把他们加给f[x][j-k]
            {
                f[x][j]=max(f[x][j],f[x][j-k]+f[y][k]);
            }
        }
    }
}

int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        int fa;
        cin>>v[i]>>w[i]>>fa; //fa是当前节点的父节点.
        if(fa==-1)
            root=i;
        else
            g[fa].push_back(i);//把i放入g[fa]中表示儿子.
    }
    dfs(root);
    cout<<f[root][m];
    return 0;
}

// 作者：yzy0611
// 链接：https://www.acwing.com/solution/content/8316/
// 来源：AcWing
// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。