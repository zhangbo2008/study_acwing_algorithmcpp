/* 
6. 多重背包问题 III
   题目
   提交记录
   讨论
   题解
   视频讲解

有 N 种物品和一个容量是 V 的背包。

第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。

输入格式
第一行两个整数，N，V (0<N≤1000, 0<V≤20000)，用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。

输出格式
输出一个整数，表示最大价值。

数据范围
0<N≤1000
0<V≤20000
0<vi,wi,si≤20000
提示
本题考查多重背包的单调队列优化方法。

输入样例
4 5
1 2 3
2 4 1
3 4 3
4 5 2
输出样例：
10 */


//队列的头是从左边. 队列的尾在右边.




#include <iostream>
#include <cstring>

using namespace std;

const int N = 20010;  //复杂度.N乘以M

int dp[N], pre[N], q[N];
int n, m;

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; ++i) {//N=1000 M=20000 //首先取定每一个物品.
        memcpy(pre, dp, sizeof(dp));//每一次算新物品要把上次的dp数据拷贝到pre里面.
        int v, w, s;
        cin >> v >> w >> s;
        for (int j = 0; j < v; ++j) {//其实这个v是很小的. 会远比M小. 所以j 按照 jmodv来计算即可. 每一个mod相同的可以用单调队列求滑动窗口最大值来加速.
            int head = 0, tail = -1;




/* 队列跟栈一样也是访问受限制的，所以队列也只有两个主要的操作：入队(enqueue)操作 和 出队(dequeue)操作 。

入队操作就是将一个元素添加到队尾
出队操作就是从队头取出一个元素。 */

//下面这段就是单调队列求滑动窗口最大值 //对于每一个取定的余数j, 我们k遍历所有的j+v的倍数.v的倍数最大是s. 因为物品数量最大是s. k表示当前存放物品的体积和.



//对着79题目进行看.
            for (int k = j; k <= m; k += v) {// f[j]=max(f[j-v]+w,...,f[j-kv]+kw)
            // 单调队列的头来维护最大值所在的索引, 尾进行插入数据.
                if (head <= tail && k - s*v > q[head]) // 滑窗大小为s //k - s*v > q[head] 说明当前窗口内的元素是k到k-s*v   // 79里面是这个代码:if(!q.empty() && i-q.front() >= k)  !q.empty().  整个队列是左边是头部, 右边是尾部.只有头小于等于尾部才是表示队列不空. 当前位置是k- 队列头部q[head]大于等于队列长度s*v
                    ++head;

                while (head <= tail && pre[q[tail]] - (q[tail] - j)/v * w <= pre[k] - (k - j)/v * w)// 维护单调队列 ,因为这2个值. pre[q[tail]] 和 pre[k] 都是从j不停的加v 加到的. 所以把他俩后面多加的减去即可比较他俩到任意值时所需要比较的相对大小!
                    --tail;

                if (head <= tail) // 单调队列取最大值 是head, 他能弹出说明他是有价值的.他就是一个max值.
                    dp[k] = max(dp[k], pre[q[head]] + (k - q[head])/v * w);

                q[++tail] = k;
            }




        }
    }
    cout << dp[m] << endl;
    return 0;
}





